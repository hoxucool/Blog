<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020-03月每日一题</title>
    <url>/Blog/2020/03/01/3%E6%9C%88%E4%BB%BD%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Xhofe/picdn/2020/06/18/89a659.png" alt="每日一题"></p>
<a id="more"></a>

<h3 id="1-10"><a href="#1-10" class="headerlink" title="1-10"></a>1-10</h3><h4 id="01-225-用队列实现栈"><a href="#01-225-用队列实现栈" class="headerlink" title="01 225. 用队列实现栈"></a>01 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXN0YWNrLXVzaW5nLXF1ZXVlcy8=">225. 用队列实现栈<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>使用队列实现栈的下列操作：</p>
<ul>
<li><p>push(x) – 元素 x 入栈</p>
</li>
<li><p>pop() – 移除栈顶元素</p>
</li>
<li><p>top() – 获取栈顶元素</p>
</li>
<li><p>empty() – 返回栈是否为空<br>注意:</p>
</li>
<li><p>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</p>
</li>
<li><p>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
</li>
<li><p>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p>
</li>
</ul>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>没啥好说的，就是一个队列存数据，一个队列辅助入栈，入栈时交换两个队列。</p>
<h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue1,queue2;</span><br><span class="line">        <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue2=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue1.add(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue2.isEmpty())queue1.add(queue2.poll());</span><br><span class="line">        Queue tmp=queue1;queue1=queue2;queue2=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="02-206-反转链表"><a href="#02-206-反转链表" class="headerlink" title="02 206. 反转链表"></a>02 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">206. 反转链表<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p>反转一个单链表。</p>
<p>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>老题目了，上数据结构的时候就说过，遍历链表，遍历到结点链接到上一个节点并记录该结点。</p>
<h5 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode last=<span class="keyword">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        ListNode next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next=cur.next;</span><br><span class="line">            cur.next=last;</span><br><span class="line">            last=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="03-面试题-10-01-合并排序的数组"><a href="#03-面试题-10-01-合并排序的数组" class="headerlink" title="03 面试题 10.01. 合并排序的数组"></a>03 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydGVkLW1lcmdlLWxjY2kv">面试题 10.01. 合并排序的数组<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h5><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
<p>示例:</p>
<blockquote>
<p>输入:<br>A = [1,2,3,0,0,0], m = 3<br>B = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
</blockquote>
<p>说明:</p>
<blockquote>
<p>A.length == n + m</p>
</blockquote>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>双指针。</p>
<h5 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=A.length-<span class="number">1</span>;</span><br><span class="line">        m-=<span class="number">1</span>;n-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m&gt;=<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[m]&gt;B[n])&#123;</span><br><span class="line">                A[i--]=A[m];m--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                A[i--]=B[n];n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            A[i--]=B[n];n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="04-994-腐烂的橘子"><a href="#04-994-腐烂的橘子" class="headerlink" title="04 994. 腐烂的橘子"></a>04 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90dGluZy1vcmFuZ2VzLw==">994. 腐烂的橘子<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h5><p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 0 代表空单元格；</li>
<li>值 1 代表新鲜橘子；</li>
<li>值 2 代表腐烂的橘子。</li>
<li>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</li>
</ul>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li>
</ol>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>模拟一遍这个过程，但是每次烂掉的橘子记为-1，之后再统一标记为2，避免一次中的腐烂传播。</p>
<h5 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(lan(grid))&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : grid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ints[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lan</span><span class="params">(<span class="keyword">int</span> [][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> lan=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=grid.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i-<span class="number">1</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[i-<span class="number">1</span>][j]=-<span class="number">1</span>;</span><br><span class="line">                        lan=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;grid.length&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[i+<span class="number">1</span>][j]=-<span class="number">1</span>;</span><br><span class="line">                        lan=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i][j-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[i][j-<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">                        lan=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;grid[<span class="number">0</span>].length&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        grid[i][j+<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">                        lan=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=grid.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==-<span class="number">1</span>)&#123;</span><br><span class="line">                    grid[i][j]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="05-1103-分糖果-II"><a href="#05-1103-分糖果-II" class="headerlink" title="05 1103. 分糖果 II"></a>05 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGlzdHJpYnV0ZS1jYW5kaWVzLXRvLXBlb3BsZS8=">1103. 分糖果 II<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h5><p>排排坐，分糖果。</p>
<p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <code>n = num_people</code>个小朋友。</p>
<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。</p>
<p>然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。</p>
<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>
<p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第<code>i</code> 个小朋友分到的糖果数）。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; 7, num_people &#x3D; 4</span><br><span class="line">输出：[1,2,3,1]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] +&#x3D; 1，数组变为 [1,0,0,0]。</span><br><span class="line">第二次，ans[1] +&#x3D; 2，数组变为 [1,2,0,0]。</span><br><span class="line">第三次，ans[2] +&#x3D; 3，数组变为 [1,2,3,0]。</span><br><span class="line">第四次，ans[3] +&#x3D; 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; 10, num_people &#x3D; 3</span><br><span class="line">输出：[5,2,3]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] +&#x3D; 1，数组变为 [1,0,0]。</span><br><span class="line">第二次，ans[1] +&#x3D; 2，数组变为 [1,2,0]。</span><br><span class="line">第三次，ans[2] +&#x3D; 3，数组变为 [1,2,3]。</span><br><span class="line">第四次，ans[0] +&#x3D; 4，最终数组变为 [5,2,3]。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li><code>1 &lt;= candies &lt;= 10^9</code></li>
<li><code>1 &lt;= num_people &lt;= 1000</code></li>
</ul>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>纯数学计算，先计算出把所有小朋友发全可以发多少次，然后剩下的糖果模拟发完为止。</p>
<h5 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] distributeCandies(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[num_people];</span><br><span class="line">        <span class="keyword">int</span> tmp=candies;</span><br><span class="line">        <span class="keyword">int</span> count=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            candies=tmp;++count;</span><br><span class="line">            tmp-=num_people*((<span class="number">2</span>*count+<span class="number">1</span>)*num_people+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_people; i++) &#123;</span><br><span class="line">            res[i]=count*(<span class="number">2</span>*(i+<span class="number">1</span>)+(count-<span class="number">1</span>)*num_people)/<span class="number">2</span>;</span><br><span class="line">            tmp=count*num_people+i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (candies&lt;=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (candies&gt;=tmp)&#123;</span><br><span class="line">                res[i]+=tmp;</span><br><span class="line">                candies-=tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res[i]+=candies;</span><br><span class="line">                candies=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="06-面试题57-II-和为s的连续正数序列"><a href="#06-面试题57-II-和为s的连续正数序列" class="headerlink" title="06 面试题57 - II. 和为s的连续正数序列"></a>06 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGUtd2VpLXNkZS1saWFuLXh1LXpoZW5nLXNodS14dS1saWUtbGNvZi8=">面试题57 - II. 和为s的连续正数序列<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h5><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：target = 9<br>输出：[[2,3,4],[4,5]]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
</blockquote>
<p>限制：</p>
<ul>
<li>1 &lt;= target &lt;= 10^5</li>
</ul>
<h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>滑动窗口，因为都是正数，要往目标和靠近，小的时候右边界右移，大的时候左边界右移。</p>
<h5 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        i = <span class="number">1</span>  <span class="comment"># 滑动窗口的左边界</span></span><br><span class="line">        j = <span class="number">1</span>  <span class="comment"># 滑动窗口的右边界</span></span><br><span class="line">        sum = <span class="number">0</span>  <span class="comment"># 滑动窗口中数字的和</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &lt;= target // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> sum &lt; target:</span><br><span class="line">                sum += j</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum &gt; target:</span><br><span class="line">                sum -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr = list(range(i, j))</span><br><span class="line">                res.append(arr)</span><br><span class="line">                sum -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="07-面试题59-II-队列的最大值"><a href="#07-面试题59-II-队列的最大值" class="headerlink" title="07 面试题59 - II. 队列的最大值"></a>07 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZHVpLWxpZS1kZS16dWktZGEtemhpLWxjb2Yv">面试题59 - II. 队列的最大值<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h5><p>请定义一个队列并实现函数<code>max_value</code>得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code>的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code>和 <code>max_value</code>需要返回 -1</p>
<p>示例 1：</p>
<blockquote>
<p><strong>输入</strong>:<br>[“<code>MaxQueue</code>“,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br><strong>输出</strong>: [null,null,null,2,1,2]</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p><strong>输入</strong>:<br>[“<code>MaxQueue</code>“,”pop_front”,”max_value”]<br>[[],[],[]]<br><strong>输出</strong>: [null,-1,-1]</p>
</blockquote>
<p>限制：</p>
<ul>
<li>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</li>
<li>1 &lt;= value &lt;= 10^5</li>
</ul>
<h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><p>当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响。所以我们只需要维护一个单调队列即可，在放入元素的时候，将单调队列里所有比该元素小的值<code>poll</code>，输出元素的时候，如果这个元素是当时的最大值，则将单调队列也进行<code>poll</code>。</p>
<h5 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">        <span class="keyword">private</span> Deque&lt;Integer&gt; max;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            max=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (max.isEmpty())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> max.getFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            queue.add(value);</span><br><span class="line">            <span class="keyword">while</span> (!max.isEmpty()&amp;&amp;max.getLast()&lt;value)max.pollLast();</span><br><span class="line">            max.add(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty())<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> value=queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (max.getFirst()==value)max.pollFirst();</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="08-322-零钱兑换"><a href="#08-322-零钱兑换" class="headerlink" title="08 322. 零钱兑换"></a>08 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2Uv">322. 零钱兑换<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h5><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>:<br>你可以认为每种硬币的数量是无限的。</p>
<h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>动态规划，属于背包问题。<code>dp[i][j]</code>记录当只用前i种硬币组合j时的最少硬币个数，则有$dp[i][j]=\min(dp[i-1][j],dp[i][j-coins[i]]+1)$.如果<code>dp[i][j-coins[i]]</code>存在的话。因为只使用了上一次的状态，所以可以用滚动数组进行优化。</p>
<h5 id="code-7"><a href="#code-7" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=coins.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;amount+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i]=Integer.MAX_VALUE/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=coins[i];j&lt;amount+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                dp[j]=Integer.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount]&gt;=amount+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="09-121-买卖股票的最佳时机"><a href="#09-121-买卖股票的最佳时机" class="headerlink" title="09 121. 买卖股票的最佳时机"></a>09 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay8=">121. 买卖股票的最佳时机<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h5><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
</blockquote>
<p>示例 2:</p>
<blockquote>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
</blockquote>
<h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>从前往后遍历，记录当前最小值与当前值减去最小值的差的最大值。</p>
<h5 id="code-8"><a href="#code-8" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            min=Math.min(min,price);</span><br><span class="line">            res=Math.max(res,price-min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-543-二叉树的直径"><a href="#10-543-二叉树的直径" class="headerlink" title="10 543. 二叉树的直径"></a>10 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGlhbWV0ZXItb2YtYmluYXJ5LXRyZWUv">543. 二叉树的直径<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h5><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例</strong> :<br>给定二叉树</p>
<pre><code>    1
   / \
  2   3
 / \     
4   5    </code></pre><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>递归，其实最大直径就是左子树的深度+右子树的深度。</p>
<h5 id="code-9"><a href="#code-9" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        deep(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=deep(node.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=deep(node.right)+<span class="number">1</span>;</span><br><span class="line">        res=Math.max(res,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-20"><a href="#11-20" class="headerlink" title="11-20"></a>11-20</h3><h4 id="11-1013-将数组分成和相等的三个部分"><a href="#11-1013-将数组分成和相等的三个部分" class="headerlink" title="11 1013. 将数组分成和相等的三个部分"></a>11 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWFycmF5LWludG8tdGhyZWUtcGFydHMtd2l0aC1lcXVhbC1zdW0v">1013. 将数组分成和相等的三个部分<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h5><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p>
<p>形式上，如果可以找出索引<code>i+1 &lt; j</code>且满足 <code>(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])</code>就可以将数组三等分。</p>
<p><strong>示例 1</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：3 + 3 &#x3D; 6 &#x3D; 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure>

<h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><p>先计算出总和，看能不能被3整除，然后模拟一下即可。</p>
<h5 id="code-10"><a href="#code-10" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: A) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            curSum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否找到了3段（注意如果目标值是0的话可以大于3段）</span></span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">3</span> || (cnt &gt; <span class="number">3</span> &amp;&amp; sum == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-1071-字符串的最大公因子"><a href="#12-1071-字符串的最大公因子" class="headerlink" title="12 1071. 字符串的最大公因子"></a>12 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ3JlYXRlc3QtY29tbW9uLWRpdmlzb3Itb2Ytc3RyaW5ncy8=">1071. 字符串的最大公因子<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h5><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p>
<p>返回最长字符串 X，要求满足 X 能除尽<code>str1</code>且 X 能除尽<code>str2</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：str1 &#x3D; &quot;ABCABC&quot;, str2 &#x3D; &quot;ABC&quot;</span><br><span class="line">输出：&quot;ABC&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：str1 &#x3D; &quot;ABABAB&quot;, str2 &#x3D; &quot;ABAB&quot;</span><br><span class="line">输出：&quot;AB&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：str1 &#x3D; &quot;LEET&quot;, str2 &#x3D; &quot;CODE&quot;</span><br><span class="line">输出：&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= str1.length &lt;= 1000</code></li>
<li><code>1 &lt;= str2.length &lt;= 1000</code></li>
<li><code>str1[i]</code>和<code>str2[i]</code>为大写英文字母</li>
</ul>
<h5 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h5><p>如果两个字符串有公因子串，则必有<code>str1+str2=str2+str1</code>，用辗转相除法计算出长度的最大公因数，截取其中一段即为最大公因子串了。</p>
<h5 id="code-11"><a href="#code-11" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(str1+str2).equals(str2+str1))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>,gcd(str1.length(),str2.length()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-169-多数元素"><a href="#13-169-多数元素" class="headerlink" title="13 169. 多数元素"></a>13 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWFqb3JpdHktZWxlbWVudC8=">169. 多数元素<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h5><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h5 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h5><p>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，因为最多的数出现的次数大于一半，所以最后总会找到这个数。</p>
<h5 id="code-12"><a href="#code-12" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num==cur)count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">                cur=num;</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-300-最长上升子序列"><a href="#14-300-最长上升子序列" class="headerlink" title="14 300. 最长上升子序列"></a>14 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlLw==">300. 最长上升子序列<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h5><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:</p>
<blockquote>
<p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p>
</blockquote>
<p>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 $O(n^2)$ 。</p>
<h5 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h5><p>常规<code>dp</code>就可以$O(n^2)$，这里参考官方题解的贪心+二分。</p>
<blockquote>
<p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>
<p>基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 ii 的最长上升子序列的末尾元素的最小值，用 $len$ 记录目前最长上升子序列的长度，起始时 $len$ 为 11，$d[1]=nums[0]$。</p>
<p>同时我们可以注意到 d[i]d[i] 是关于 ii 单调递增的。因为如果 $d[j] \geq d[i]$且$ j &lt; i$，我们考虑从长度为 ii 的最长上升子序列的末尾删除 $i-j$ 个元素，那么这个序列长度变为 j，且第 j个元素 xx（末尾元素）必然小于 d[i]，也就小于 d[j]。那么我们就找到了一个长度为 j的最长上升子序列，并且末尾元素比 d[j] 小，从而产生了矛盾。因此数组 d[] 的单调性得证。</p>
<p>我们依次遍历数组 $nums[] $中的每个元素，并更新数组 d[]d[] 和 $len$ 的值。如果$ \textit{nums}[i] &gt; d[\textit{len}] $则更新 $len = len + 1$，否则在 $d[1 \ldots len]$中找满足$ d[i−1]&lt;nums[j]&lt;d[i] $的下标 ii，并更新 $d[i]=nums[j]$。</p>
<p>根据 d 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。</p>
<p>最后整个算法流程为：</p>
<p>设当前已求出的最长上升子序列的长度为$ len$（初始时为 11），从前往后遍历数组 $nums$，在遍历到 $nums[i] $时：</p>
<p>如果$nums[i]&gt;d[len] $，则直接加入到 d 数组末尾，并更新 $len=len+1$；</p>
<p>否则，在 d 数组中二分查找，找到第一个比$nums[i] $小的数 d[k] ，并更新 $d[k+1]=nums[i]$。</p>
<p>作者：<code>LeetCode-Solution</code><br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlL3NvbHV0aW9uL3p1aS1jaGFuZy1zaGFuZy1zaGVuZy16aS14dS1saWUtYnktbGVldGNvZGUtc29sdXRpLw==">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h5 id="code-13"><a href="#code-13" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, n = (<span class="keyword">int</span>)nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] d=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) d[++len] = nums[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">1</span>, r = len, pos = <span class="number">0</span>; <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-695-岛屿的最大面积"><a href="#15-695-岛屿的最大面积" class="headerlink" title="15 695. 岛屿的最大面积"></a>15 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LWFyZWEtb2YtaXNsYW5kLw==">695. 岛屿的最大面积<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h5><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p>
<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。（如果没有岛屿，则返回面积为 0 。)</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure>


<p>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0,0,0,0,0,0,0,0]]</span><br></pre></td></tr></table></figure>

<p>对于上面这个给定的矩阵, 返回 <code>0</code>。</p>
<h5 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h5><p>对于每个1进行<code>dfs</code>。下面的代码其实可以不必使用cur标记是否访问，直接对访问过进行置0即可。</p>
<h5 id="code-14"><a href="#code-14" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]conditions=&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] cur;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cur=<span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> cur_res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>&amp;&amp;!cur[i][j])&#123;</span><br><span class="line">                    cur_res=maxAreaOfIsland(grid,i,j);</span><br><span class="line">                    res=Math.max(res,cur_res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur_res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i==grid.length||j&lt;<span class="number">0</span>||j==grid[<span class="number">0</span>].length||cur[i][j]||grid[i][j]!=<span class="number">1</span>)<span class="keyword">return</span> cur_res;</span><br><span class="line">        cur_res++;</span><br><span class="line">        cur[i][j]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            cur_res+=maxAreaOfIsland(grid,i+conditions[k][<span class="number">0</span>],j+conditions[k][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur_res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-面试题-01-06-字符串压缩"><a href="#16-面试题-01-06-字符串压缩" class="headerlink" title="16 面试题 01.06. 字符串压缩"></a>16 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tcHJlc3Mtc3RyaW5nLWxjY2kv">面试题 01.06. 字符串压缩<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h5><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串<code>aabcccccaaa</code>会变为<code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aabcccccaaa&quot;</span><br><span class="line">输出：&quot;a2b1c5a3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abbccd&quot;</span><br><span class="line">输出：&quot;abbccd&quot;</span><br><span class="line">解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>字符串长度在[0, 50000]范围内。</li>
</ul>
<h5 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h5><p>直接模拟这个过程即可。</p>
<h5 id="code-15"><a href="#code-15" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S.length()&lt;<span class="number">3</span>)<span class="keyword">return</span> S;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span> c=S.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i)==c)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(c).append(count);</span><br><span class="line">                <span class="keyword">if</span> (sb.length()&gt;=S.length())&#123;</span><br><span class="line">                    <span class="keyword">return</span> S;</span><br><span class="line">                &#125;</span><br><span class="line">                c=S.charAt(i);</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(c).append(count);</span><br><span class="line">        <span class="keyword">if</span> (sb.length()&gt;=S.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-1160-拼写单词"><a href="#17-1160-拼写单词" class="headerlink" title="17 1160. 拼写单词"></a>17 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC13b3Jkcy10aGF0LWNhbi1iZS1mb3JtZWQtYnktY2hhcmFjdGVycy8=">1160. 拼写单词<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h5><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p>
<p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>
<p>注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</p>
<p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars &#x3D; &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 &#x3D; 6。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars &#x3D; &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 &#x3D; 10。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li>
<li>所有字符串中都仅包含小写英文字母</li>
</ul>
<h5 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h5><p>只有26个字母，直接数组哈希。逐个测试即可。</p>
<h5 id="code-16"><a href="#code-16" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : chars.toCharArray())&#123;</span><br><span class="line">            hash[ch - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            Arrays.fill(map, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch : word.toCharArray())&#123;</span><br><span class="line">                map[ch - <span class="string">'a'</span>]++;</span><br><span class="line">                <span class="keyword">if</span>(map[ch - <span class="string">'a'</span>] &gt; hash[ch - <span class="string">'a'</span>]) flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len += flag ? word.length() : <span class="number">0</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-836-矩形重叠"><a href="#18-836-矩形重叠" class="headerlink" title="18 836. 矩形重叠"></a>18 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVjdGFuZ2xlLW92ZXJsYXAv">836. 矩形重叠<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h5><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p>
<p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p>
<p>给出两个矩形，判断它们是否重叠并返回结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 &#x3D; [0,0,2,2], rec2 &#x3D; [1,1,3,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：rec1 &#x3D; [0,0,1,1], rec2 &#x3D; [1,0,2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。</li>
<li>矩形中的所有坐标都处于 -10^9 和 10^9 之间。</li>
<li>x 轴默认指向右，y 轴默认指向上。</li>
<li>你可以仅考虑矩形是正放的情况。</li>
</ul>
<h5 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVjdGFuZ2xlLW92ZXJsYXAvY29tbWVudHMvMjkyMDYz">思路<i class="fa fa-external-link-alt"></i></span></h5><p>矩形如果不重叠，从x轴和y轴上看两个矩形就变成了两条线段，这两条线段肯定是不相交的，也就是说左边的矩形的最右边小于右边矩形的最左边，也就是<code>rec1[2] &lt; rec2[0] || rec2[2] &lt; rec1[0]</code>；y轴同理，下面的矩形的最上边小于上面矩形的最下边，也就是<code>rec1[3] &lt; rec2[1] || rec2[3] &lt; rec1[1]</code>。因为题目要求重叠算相离，所以加上<code>=</code>，最后取反就行啦~</p>
<h5 id="code-17"><a href="#code-17" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] || rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>] || rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] || rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="19-409-最长回文串"><a href="#19-409-最长回文串" class="headerlink" title="19 409. 最长回文串"></a>19 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21lLw==">409. 最长回文串<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h5><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>
<p><strong>注意:</strong><br>假设字符串的长度不会超过 1010。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>

<h5 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h5><p>直接统计每个字符的个数。只要是复数出现的即可，最后还可以加上一个正中间的。</p>
<h5 id="code-18"><a href="#code-18" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">             cnts[s.charAt(i) - <span class="string">'A'</span>]++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">int</span> palindrome = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> cnt : cnts) &#123;</span><br><span class="line">             palindrome += (cnt / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (palindrome &lt; s.length()) &#123;</span><br><span class="line">             palindrome++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> palindrome;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="20-面试题40-最小的k个数"><a href="#20-面试题40-最小的k个数" class="headerlink" title="20 面试题40. 最小的k个数"></a>20 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvenVpLXhpYW8tZGUta2dlLXNodS1sY29mLw==">面试题40. 最小的k个数<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h5><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
<h5 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h5><p>二分法，每次取mid，将数组分为两个部分，如果小的那部分&gt;k，则继续再这部分进行二分，如果&lt;k，则这些数都是结果，再在大的部分继续取剩下的数，如果刚好等于要取的数，则结束。</p>
<h5 id="code-19"><a href="#code-19" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> len=arr.length;</span><br><span class="line">        <span class="keyword">int</span> leftL,rightL;</span><br><span class="line">        <span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">int</span>[] midA=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> midL;</span><br><span class="line">        <span class="keyword">while</span> (index&lt;k)&#123;</span><br><span class="line">            leftL=<span class="number">0</span>;rightL=<span class="number">0</span>;midL=<span class="number">0</span>;</span><br><span class="line">            mid=arr[len/<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i]&lt;mid)&#123;</span><br><span class="line">                    left[leftL++]=arr[i];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i]==mid)midA[midL++]=arr[i];</span><br><span class="line">                <span class="keyword">else</span> right[rightL++]=arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (leftL&gt;(k-index))&#123;</span><br><span class="line">                arr=left;</span><br><span class="line">                len=leftL;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leftL; i++) &#123;</span><br><span class="line">                    res[index++]=left[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (index&lt;k&amp;&amp;tmp&lt;midL)&#123;</span><br><span class="line">                    res[index++]=midA[tmp++];</span><br><span class="line">                &#125;</span><br><span class="line">                arr=right;</span><br><span class="line">                len=rightL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-31"><a href="#21-31" class="headerlink" title="21-31"></a>21-31</h3><h4 id="21-365-水壶问题"><a href="#21-365-水壶问题" class="headerlink" title="21 365. 水壶问题"></a>21 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2F0ZXItYW5kLWp1Zy1wcm9ibGVtLw==">365. 水壶问题<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h5><p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<p><strong>示例 1:</strong> (From the famous <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1CVnRRTktfWlVKZw==">*”Die Hard”* example<i class="fa fa-external-link-alt"></i></span>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 3, y &#x3D; 5, z &#x3D; 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<h5 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2F0ZXItYW5kLWp1Zy1wcm9ibGVtL3NvbHV0aW9uL3NodWktaHUtd2VuLXRpLWJ5LWxlZXRjb2RlLXNvbHV0aW9uLw==">思路<i class="fa fa-external-link-alt"></i></span></h5><blockquote>
<p>预备知识：贝祖定理</p>
<p>我们认为，每次操作只会让桶里的水总量增加 x，增加 y，减少 x，或者减少 y。</p>
<p>你可能认为这有问题：如果往一个不满的桶里放水，或者把它排空呢？那变化量不就不是 x 或者 y 了吗？接下来我们来解释这一点：</p>
<p>首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。因为观察所有题目中的操作，操作的结果都至少有一个桶是空的或者满的；</p>
<p>其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；</p>
<p>再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。</p>
<p>因此，我们可以认为每次操作只会给水的总量带来 x 或者 y 的变化量。因此我们的目标可以改写成：找到一对整数 a,b，使得</p>
<p>$$ax+by=z$$</p>
<p>而只要满足z≤x+y，且这样的 a,b 存在，那么我们的目标就是可以达成的。这是因为：</p>
<ul>
<li><p>若a≥0,b≥0，那么显然可以达成目标。</p>
</li>
<li><p>若a&lt;0，那么可以进行以下操作：</p>
<ol>
<li><p>往 y 壶倒水；</p>
</li>
<li><p>把 y 壶的水倒入 x 壶；</p>
</li>
<li><p>如果 y 壶不为空，那么 x 壶肯定是满的，把 x 壶倒空，然后再把 y 壶的水倒入 x 壶。</p>
</li>
</ol>
<p>重复以上操作直至某一步时 x 壶进行了 a 次倒空操作，y 壶进行了 b 次倒水操作。</p>
</li>
<li><p>若 b&lt;0，方法同上，x 与 y 互换。</p>
</li>
</ul>
<p>而贝祖定理告诉我们，ax+by=z 有解当且仅当 z 是 x,y 的最大公约数的倍数。因此我们只需要找到x,y 的最大公约数并判断 z 是否是它的倍数即可。</p>
</blockquote>
<h5 id="code-20"><a href="#code-20" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (x+y&lt;z)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (x+y==z||x==z||y==z||x==<span class="number">1</span>||y==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (x==y||x==<span class="number">0</span>||y==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> gcd=getGCD(x,y);</span><br><span class="line">        <span class="keyword">if</span> (gcd==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> gcd&lt;z&amp;&amp;z%gcd==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 数学上不考虑负数的约数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (a % b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a % b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="22-945-使数组唯一的最小增量"><a href="#22-945-使数组唯一的最小增量" class="headerlink" title="22 945. 使数组唯一的最小增量"></a>22 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1pbmNyZW1lbnQtdG8tbWFrZS1hcnJheS11bmlxdWUv">945. 使数组唯一的最小增量<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h5><p>给定整数数组 A，每次 <em>move</em> 操作将会选择任意 <code>A[i]</code>，并将其递增 <code>1</code>。</p>
<p>返回使 <code>A</code> 中的每个值都是唯一的最少操作次数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,2,1,2,1,7]</span><br><span class="line">输出：6</span><br><span class="line">解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。</span><br><span class="line">可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 40000</code></li>
<li><code>0 &lt;= A[i] &lt; 40000</code></li>
</ol>
<h5 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h5><p>首先模拟也可以做，但是很慢，所以可以利用空间换时间的方法，记录下所有的数出现的次数，遍历这些数，对于每个数出现次数&gt;1的数进行次数-1的move操作，所以该数+1要的次数要加上该数的次数-1，结果加上move的次数即可。</p>
<h5 id="code-21"><a href="#code-21" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Arrays.sort(A);</span></span><br><span class="line">        <span class="comment">// int res=0;</span></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt; A.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     while (A[i]&lt;=A[i-1])&#123;</span></span><br><span class="line">        <span class="comment">//         A[i]++;</span></span><br><span class="line">        <span class="comment">//         res++;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        <span class="comment">//空间换时间</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50000</span>];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A)&#123;</span><br><span class="line">            arr[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                arr[i+<span class="number">1</span>]+=arr[i]-<span class="number">1</span>;</span><br><span class="line">                res+=arr[i]-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-876-链表的中间结点"><a href="#23-876-链表的中间结点" class="headerlink" title="23 876. 链表的中间结点"></a>23 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWlkZGxlLW9mLXRoZS1saW5rZWQtbGlzdC8=">876. 链表的中间结点<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h5><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li>
</ul>
<h5 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h5><p>经典的快慢指针用法。</p>
<h5 id="code-22"><a href="#code-22" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        ListNode low = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="24-面试题-17-16-按摩师"><a href="#24-面试题-17-16-按摩师" class="headerlink" title="24 面试题 17.16. 按摩师"></a>24 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdGhlLW1hc3NldXNlLWxjY2kv">面试题 17.16. 按摩师<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h5><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。</span><br></pre></td></tr></table></figure>

<h5 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h5><p>动态规划：$dp[i]=\max(dp[i-1],dp[i-2]+nums[i])$</p>
<h5 id="code-23"><a href="#code-23" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]= Math.max(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="25-892-三维形体的表面积"><a href="#25-892-三维形体的表面积" class="headerlink" title="25 892. 三维形体的表面积"></a>25 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VyZmFjZS1hcmVhLW9mLTNkLXNoYXBlcy8=">892. 三维形体的表面积<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h5><p>在 <code>N * N</code> 的网格上，我们放置一些 <code>1 * 1 * 1</code> 的立方体。</p>
<p>每个值 <code>v = grid[i][j]</code> 表示 <code>v</code> 个正方体叠放在对应单元格 <code>(i, j)</code> 上。</p>
<p>请你返回最终形体的表面积。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2]]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2],[3,4]]</span><br><span class="line">输出：34</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0],[0,2]]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">输出：46</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= N &lt;= 50</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>
</ul>
<h5 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h5><p>对于每个格子里的正方体，首先是上下两个面，然后是每个有四个侧面，最后减去重复计算的侧面即可。</p>
<h5 id="code-24"><a href="#code-24" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    res+=<span class="number">2</span>;</span><br><span class="line">                    res+=grid[i][j]&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;<span class="number">0</span>)res-=Math.min(grid[i][j],grid[i-<span class="number">1</span>][j])&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j&gt;<span class="number">0</span>)res-=Math.min(grid[i][j],grid[i][j-<span class="number">1</span>])&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// if (i&lt;grid.length-1)res-=Math.min(grid[i][j],grid[i+1][j]);</span></span><br><span class="line">                    <span class="comment">// if (j&lt;grid[0].length-1)res-=Math.min(grid[i][j],grid[i][j+1]);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="26-999-可以被一步捕获的棋子数"><a href="#26-999-可以被一步捕获的棋子数" class="headerlink" title="26 999. 可以被一步捕获的棋子数"></a>26 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXZhaWxhYmxlLWNhcHR1cmVzLWZvci1yb29rLw==">999. 可以被一步捕获的棋子数<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h5><p>在一个 8 x 8 的棋盘上，有一个白色的车（<code>Rook</code>），用字符 <code>&#39;R&#39;</code> 表示。棋盘上还可能存在空方块，白色的象（<code>Bishop</code>）以及黑色的卒（<code>pawn</code>），分别用字符 <code>&#39;.&#39;</code>，<code>&#39;B&#39;</code> 和 <code>&#39;p&#39;</code> 表示。不难看出，大写字符表示的是白棋，小写字符表示的是黑棋。</p>
<p>车按国际象棋中的规则移动。东，西，南，北四个基本方向任选其一，然后一直向选定的方向移动，直到满足下列四个条件之一：</p>
<ul>
<li>棋手选择主动停下来。</li>
<li>棋子因到达棋盘的边缘而停下。</li>
<li>棋子移动到某一方格来捕获位于该方格上敌方（黑色）的卒，停在该方格内。</li>
<li>车不能进入/越过已经放有其他友方棋子（白色的象）的方格，停在友方棋子前。</li>
</ul>
<p>你现在可以控制车移动一次，请你统计有多少敌方的卒处于你的捕获范围内（即，可以被一步捕获的棋子数）。</p>
<p><strong>示例 1：</strong></p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG" style="zoom:50%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">在本例中，车能够捕获所有的卒。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li><code>board.length == board[i].length == 8</code></li>
<li><code>board[i][j]</code>可以是<code>&#39;R&#39;，&#39;.&#39;，&#39;B&#39;</code>或 <code>&#39;p&#39;</code></li>
<li>只有一个格子上存在<code>board[i][j] == &#39;R&#39;</code></li>
</ol>
<h5 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h5><p>很没意思的一道题。。。。</p>
<h5 id="code-25"><a href="#code-25" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>,col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j]==<span class="string">'R'</span>)&#123;</span><br><span class="line">                    row=i;col=j;<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp=row-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=board[tmp][col];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'B'</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'p'</span>)&#123;res++;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=row+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&lt;board.length)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=board[tmp][col];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'B'</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'p'</span>)&#123;res++;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=col-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=board[row][tmp];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'B'</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'p'</span>)&#123;res++;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=col+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp&lt;board[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=board[row][tmp];</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'B'</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">'p'</span>)&#123;res++;<span class="keyword">break</span>;&#125;</span><br><span class="line">            tmp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="27-914-卡牌分组"><a href="#27-914-卡牌分组" class="headerlink" title="27 914. 卡牌分组"></a>27 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMveC1vZi1hLWtpbmQtaW4tYS1kZWNrLW9mLWNhcmRzLw==">914. 卡牌分组<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h5><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<ul>
<li>每组都有 <code>X</code> 张牌。</li>
<li>组内所有的牌上都写着相同的整数。</li>
</ul>
<p>仅当你可选的 <code>X &gt;= 2</code> 时返回 <code>true</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,2,2,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[2,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= deck.length &lt;= 10000</code></li>
<li><code>0 &lt;= deck[i] &lt; 10000</code></li>
</ol>
<h5 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h5><p>先给这些牌排个序。</p>
<p>然后记录所有牌的张数。以及最少的张数。</p>
<p>然后从2…最少的张数进行测试可否分组。</p>
<p>下面的代码写成hash会更好一点，懒得写了。。</p>
<h5 id="code-26"><a href="#code-26" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(deck);</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; deck.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deck[i]==deck[i-<span class="number">1</span>])tmp++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                min=Math.min(min,tmp);</span><br><span class="line">                list.add(tmp);</span><br><span class="line">                tmp=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        min=Math.min(min,tmp);</span><br><span class="line">        list.add(tmp);</span><br><span class="line">        tmp=min;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= min; i++) &#123;</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (min%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (Integer ii:list)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (ii % i != <span class="number">0</span>) &#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="28-820-单词的压缩编码"><a href="#28-820-单词的压缩编码" class="headerlink" title="28 820. 单词的压缩编码"></a>28 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2hvcnQtZW5jb2Rpbmctb2Ytd29yZHMv">820. 单词的压缩编码<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h5><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 <code>S</code> 与一个索引列表 <code>A</code>。</p>
<p>例如，如果这个列表是 <code>[&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</code>，我们就可以将其表示为 <code>S = &quot;time#bell#&quot;</code> 和 <code>indexes = [0, 2, 5]</code>。</p>
<p>对于每一个索引，我们可以通过从字符串 <code>S</code> 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p>
<p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">输出: 10</span><br><span class="line">说明: S &#x3D; &quot;time#bell#&quot; ， indexes &#x3D; [0, 2, 5] 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 7</code></li>
<li>每个单词都是小写字母 。</li>
</ol>
<h5 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h5><p>很烂的思路，先对单词进行按长度排序。然后遍历判断是否以其他单词结尾的，如果有单词被别的单词包含就不计算，最后的结果就是没有被包含的单词的长度+1的和。</p>
<p>最好的做法是用字典树（前缀树），奈何不会~待学。。</p>
<p>这道题将字符串倒过来就是判断前缀是否包含单词了。</p>
<h5 id="code-27"><a href="#code-27" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(words,(a,b)-&gt;(Integer.compare(b.length(), a.length())));</span><br><span class="line">        <span class="keyword">boolean</span>[] flags=<span class="keyword">new</span> <span class="keyword">boolean</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            String tmp=words[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; words.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flags[j]&amp;&amp;tmp.endsWith(words[j]))&#123;</span><br><span class="line">                    flags[j]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flags[i])res+=words[i].length()+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2hvcnQtZW5jb2Rpbmctb2Ytd29yZHMvc29sdXRpb24vOTktamF2YS10cmllLXR1LXhpZS1nb25nLWx1ZS1iYW8tamlhby1iYW8taHVpLWJ5LXMv">字典树做法<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="comment">// 先对单词列表根据单词长度由长到短排序</span></span><br><span class="line">        Arrays.sort(words, (s1, s2) -&gt; s2.length() - s1.length());</span><br><span class="line">        <span class="comment">// 单词插入trie，返回该单词增加的编码长度</span></span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            len += trie.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义tire</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    TrieNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode cur = root;</span><br><span class="line">        <span class="keyword">boolean</span> isNew = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 倒着插入单词</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = word.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = word.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[c] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                isNew = <span class="keyword">true</span>; <span class="comment">// 是新单词</span></span><br><span class="line">                cur.children[c] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是新单词的话编码长度增加新单词的长度+1，否则不变。</span></span><br><span class="line">        <span class="keyword">return</span> isNew? word.length() + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="29-1162-地图分析"><a href="#29-1162-地图分析" class="headerlink" title="29 1162. 地图分析"></a>29 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXMtZmFyLWZyb20tbGFuZC1hcy1wb3NzaWJsZS8=">1162. 地图分析<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h5><p>你现在手里有一份大小为 N x N 的「地图」（网格） <code>grid</code>，上面的每个「区域」（单元格）都用 <code>0</code> 和 <code>1</code> 标记好了。其中 <code>0</code> 代表海洋，<code>1</code> 代表陆地，请你找出一个海洋区域，这个海洋区域到离它最近的陆地区域的距离是最大的。</p>
<p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：<code>(x0, y0)</code> 和 <code>(x1, y1)</code> 这两个区域之间的距离是 <code>|x0 - x1| + |y0 - y1|</code> 。</p>
<p>如果我们的地图上只有陆地或者海洋，请返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex1.jpeg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释： </span><br><span class="line">海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex2.jpeg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,0,0],[0,0,0],[0,0,0]]</span><br><span class="line">输出：4</span><br><span class="line">解释： </span><br><span class="line">海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> 不是 <code>0</code> 就是 <code>1</code></li>
</ol>
<h5 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h5><p>先找出所有的陆地，再从陆地开始进行分层的<code>BFS</code>，遍历的最大深度即为解。</p>
<h5 id="code-28"><a href="#code-28" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][]conditions=&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        <span class="keyword">int</span> N=grid.length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (queue.size()==N*N||queue.size()==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">int</span> tmp=queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; tmp; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] poi=queue.poll();</span><br><span class="line">                <span class="keyword">int</span> i=poi[<span class="number">0</span>],j=poi[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newi=i+conditions[l][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> newj=j+conditions[l][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newi&lt;<span class="number">0</span>||newj&lt;<span class="number">0</span>||newi==N||newj==N)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[newi][newj]==<span class="number">0</span>)&#123;</span><br><span class="line">                        grid[newi][newj]=-<span class="number">1</span>;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newi,newj&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="30-面试题62-圆圈中最后剩下的数字"><a href="#30-面试题62-圆圈中最后剩下的数字" class="headerlink" title="30 面试题62. 圆圈中最后剩下的数字"></a>30 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMveXVhbi1xdWFuLXpob25nLXp1aS1ob3Utc2hlbmcteGlhLWRlLXNodS16aS1sY29mLw==">面试题62. 圆圈中最后剩下的数字<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h5><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
<h5 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h5><p>首先是模拟这个过程，但是会超时，官方给出<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMveXVhbi1xdWFuLXpob25nLXp1aS1ob3Utc2hlbmcteGlhLWRlLXNodS16aS1sY29mL3NvbHV0aW9uL3NpLWNob25nLWZhbmctZmEteGlhbmcteGktamllLWRhLWJ5LXl1YW5uaW5lc3Vucy8=">数学法<i class="fa fa-external-link-alt"></i></span>：</p>
<blockquote>
<p>【思路】</p>
<p>n个数字的圆圈，不断删除第m个数字，我们把最后剩下的数字记为f(n,m)<br>n个数字中第一个被删除的数字是(m-1)%n (取余的原因是m可能比n大)， 我们记作k，k=(m-1)%n<br>那么剩下的n-1个数字就变成了：0,1,……k-1,k+1,……,n-1，我们把下一轮第一个数字排在最前面，并且将这个长度为n-1的数组映射到0~n-2。</p>
<table>
<thead>
<tr>
<th>原始数组</th>
<th>映射数字</th>
</tr>
</thead>
<tbody><tr>
<td>k+1</td>
<td>0</td>
</tr>
<tr>
<td>k+2</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n-1</td>
<td>n-k-2</td>
</tr>
<tr>
<td>0</td>
<td>n-k-1</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>k-1</td>
<td>n-2</td>
</tr>
</tbody></table>
<p>把映射数字记为x，原始数字记为y，那么映射数字变回原始数字的公式为<br>$$y=(x+k+1)\mod n$$</p>
<p>在映射数字中，n-1个数字，不断删除第m个数字，由定义可以知道，最后剩下的数字为f(n-1,m)。我们把它变回原始数字，由上一个公式可以得到最后剩下的原始数字是（f(n-1,m)+k+1)%n，而这个数字也就是一开始我们标记的f(n,m)，所以可以推得递归公式为<br>$$f(n,m) =(f(n-1,m)+k+1)\mod n$$</p>
<p>将k=(m-1)%n代入，化简得到：<br>$$f(n,m) =(f(n-1,m)+m)\mod n， 且f(1,m) = 0$$</p>
<p>代码中可以采用迭代或者递归的方法实现该递归公式。时间复杂度为O(n)，空间复杂度为O(1)<br>注意公式中的mod就等同于%，为取模运算。值得注意的是，在数学中，下式成立：(a%n+b)%n=(a+b)%n</p>
</blockquote>
<h5 id="code-29"><a href="#code-29" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟法</span></span><br><span class="line">        <span class="comment">// boolean[] flag=new boolean[n];</span></span><br><span class="line">        <span class="comment">// int index=-1;</span></span><br><span class="line">        <span class="comment">// int tmp;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n-1; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     tmp=m;</span></span><br><span class="line">        <span class="comment">//     while (tmp!=0)&#123;</span></span><br><span class="line">        <span class="comment">//         if (++index==n)index=0;</span></span><br><span class="line">        <span class="comment">//         if (!flag[index])&#123;</span></span><br><span class="line">        <span class="comment">//             --tmp;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     flag[index]=true;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     if (!flag[i])return i;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return 0;</span></span><br><span class="line">        <span class="comment">// 数学法tql</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            res = (res + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="31-912-排序数组"><a href="#31-912-排序数组" class="headerlink" title="31 912. 排序数组"></a>31 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS8=">912. 排序数组<i class="fa fa-external-link-alt"></i></span></h4><h5 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h5><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>-50000 &lt;= nums[i] &lt;= 50000</code></li>
</ol>
<h5 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h5><p>各种排序~</p>
<h5 id="code-30"><a href="#code-30" class="headerlink" title="code"></a>code</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Sort（未完成）"><a href="#Sort（未完成）" class="headerlink" title="Sort（未完成）"></a>Sort（未完成）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> structure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手撕一下排序，复习排序算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//比较类排序-------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//交换类----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序(稳定)：每次走完一趟，最大的值就会到最后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.length;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序(不稳定)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=partition(arr,left,right);</span><br><span class="line">            quickSort(arr,left,index-<span class="number">1</span>);</span><br><span class="line">            quickSort(arr,index+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[]arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=arr[left];</span><br><span class="line">        <span class="keyword">int</span> index=left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;pivot)&#123;</span><br><span class="line">                swap(arr,i,index);</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,left,index-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> index-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入类---------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr==<span class="keyword">null</span>||arr.length==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;<span class="number">0</span>&amp;&amp;arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">                swap(arr,j,j-<span class="number">1</span>);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap=len/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap=gap/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                <span class="keyword">int</span> cur=arr[i];</span><br><span class="line">                <span class="keyword">while</span> (j&gt;=gap&amp;&amp;cur&lt;arr[j-gap])&#123;</span><br><span class="line">                    arr[j]=arr[j-gap];</span><br><span class="line">                    j=j-gap;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j]=cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选择类---------------------</span></span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=arr.length;</span><br><span class="line">        <span class="keyword">int</span> minIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            minIndex=i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j]&lt;arr[minIndex])minIndex=j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并类---------------------</span></span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(arr,left,mid);</span><br><span class="line">        mergeSort(arr,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">int</span>[] tmp=<span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>,index1=left,index2=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1&lt;=mid&amp;&amp;index2&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index1]&lt;arr[index2])&#123;</span><br><span class="line">                tmp[index++]=arr[index1++];</span><br><span class="line">            &#125;<span class="keyword">else</span> tmp[index++]=arr[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index1&lt;=mid)tmp[index++]=arr[index1++];</span><br><span class="line">        <span class="keyword">while</span> (index2&lt;=right)tmp[index++]=arr[index2++];</span><br><span class="line">        System.arraycopy(tmp, <span class="number">0</span>, arr, left, tmp.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//非比较排序--------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//计数排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> maxValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counts=<span class="keyword">new</span> <span class="keyword">int</span>[maxValue+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">            counts[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxValue+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count=counts[i];</span><br><span class="line">            <span class="keyword">while</span> (count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">                arr[index++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TODO 桶排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> bucketSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue=arr[<span class="number">0</span>],minValue=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;maxValue)maxValue=arr[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i]&lt;minValue)minValue=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bucketCount=(maxValue-minValue)/bucketSize+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> maxDigit)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer, Queue&lt;Integer&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> mod=<span class="number">10</span>,dev=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++,dev*=<span class="number">10</span>,mod*=<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">                <span class="keyword">int</span> bucket = (value % mod) / dev;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(bucket)) &#123;</span><br><span class="line">                    map.put(bucket, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(bucket).add(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(j))&#123;</span><br><span class="line">                    <span class="keyword">int</span> len=map.get(j).size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">                        arr[pos++]=map.get(j).poll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 另一个下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Actions的简单使用</title>
    <url>/Blog/2020/04/13/GitHub%20Actions%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Xhofe/picdn/2020/06/18/b9a333.png" alt="Github Actions"></p>
<a id="more"></a>

<h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p>要使用Github Actions，首先要了解CI/CD的概念，在软件工程中，CI / CD或CICD通常是指持续集成以及持续交付或持续部署的组合实践(from <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ0kvQ0Q=">wiki<i class="fa fa-external-link-alt"></i></span>)。具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。</p>
<h3 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h3><p>GitHub Actions 就是 GitHub 的持续集成服务，于2018年10月推出，类似于Travis-ci可以帮助我们做持续集成。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>先来看一个基础的actions文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> <span class="string">[</span> <span class="string">master</span> <span class="string">]</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> <span class="string">[</span> <span class="string">master</span> <span class="string">]</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">a</span> <span class="string">one-line</span> <span class="string">script</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">echo</span> <span class="string">Hello,</span> <span class="string">world!</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">a</span> <span class="string">multi-line</span> <span class="string">script</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">Add</span> <span class="string">other</span> <span class="string">actions</span> <span class="string">to</span> <span class="string">build,</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">test,</span> <span class="string">and</span> <span class="string">deploy</span> <span class="string">your</span> <span class="string">project.</span></span><br></pre></td></tr></table></figure>

<p>GitHub Actions 有一些自己的术语。</p>
<p>（1）<strong>workflow</strong> （工作流程）：持续集成一次运行的过程，就是一个 workflow。</p>
<p>（2）<strong>job</strong> （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</p>
<p>（3）<strong>step</strong>（步骤）：每个 job 由多个 step 构成，一步步完成。</p>
<p>（4）<strong>action</strong> （动作）：每个 step 可以依次执行一个或多个命令（action）。</p>
<h3 id="文件详解"><a href="#文件详解" class="headerlink" title="文件详解"></a>文件详解</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>首先就是name，name就是这个actions的名字；</p>
<h4 id="on"><a href="#on" class="headerlink" title="on"></a>on</h4><p>on：是指什么时候会触发这个action，常用的是<code>push</code>；</p>
<p>也可指定分支或路径：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">	<span class="attr">push:</span></span><br><span class="line">		<span class="attr">branches:</span> <span class="string">[master]</span></span><br><span class="line">		<span class="attr">paths:</span> <span class="string">[src/*]</span></span><br></pre></td></tr></table></figure>

<p>或者指定时间除出发(每15分钟执行一次)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="comment"># * is a special character in YAML so you have to quote this string</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span>  <span class="string">'*/15 * * * *'</span></span><br></pre></td></tr></table></figure>

<h4 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">	<span class="attr">job_name:</span></span><br><span class="line">		<span class="attr">runs-on:</span> <span class="string">运行actions的环境，如</span>	<span class="string">ubuntu-latest</span></span><br><span class="line">		<span class="attr">container:</span> <span class="comment">#在容器中运行</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">node:10.16-jessie</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="attr">NODE_ENV:</span> <span class="string">development</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">my_docker_volume:/volume_mount</span></span><br><span class="line">          <span class="attr">options:</span> <span class="string">--cpus</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">services:</span> <span class="comment">#用于为工作流程中的作业托管服务容器</span></span><br><span class="line">          <span class="attr">nginx:</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">            <span class="comment"># Map port 8080 on the Docker host to port 80 on the nginx container</span></span><br><span class="line">            <span class="attr">ports:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">		<span class="attr">needs:</span> <span class="string">在这之前需要执行的job，如pre_job</span></span><br><span class="line">		<span class="attr">strategy:</span> <span class="string">多策略</span></span><br><span class="line">			<span class="attr">matrix:</span></span><br><span class="line">    		<span class="attr">node:</span> <span class="string">[6,</span> <span class="number">8</span><span class="string">,</span> <span class="number">10</span><span class="string">]</span></span><br><span class="line">		<span class="attr">timeout-minutes:</span> <span class="number">360</span> <span class="comment">#让作业运行的最大分钟数。 默认值：360</span></span><br><span class="line">		<span class="attr">steps:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span> <span class="comment">#下载git库中的文件,uses复用流程</span></span><br><span class="line">		  <span class="attr">with:</span> <span class="comment">#传入环境变量</span></span><br><span class="line">		  	<span class="attr">env:</span> <span class="string">env_val</span></span><br><span class="line">		  	<span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node</span> <span class="string">&#125;&#125;</span></span><br><span class="line">		<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step_name</span></span><br><span class="line">		  <span class="attr">run:</span> <span class="string">run_scrpits</span></span><br><span class="line">		  <span class="attr">env:</span> <span class="comment">#环境变量</span></span><br><span class="line">		  	<span class="attr">name:</span> <span class="string">x</span></span><br><span class="line">		  	<span class="attr">val:</span> <span class="string">h</span></span><br><span class="line">	<span class="attr">pre_job:</span></span><br><span class="line">		<span class="attr">runs-on:</span> <span class="string">macos-latest</span></span><br><span class="line">		<span class="attr">outputs:</span> <span class="comment">#作业的输出 map。 作业输出可用于所有依赖此作业的下游作业。</span></span><br><span class="line">			<span class="attr">output1:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.step1.outputs.test</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      		<span class="attr">output2:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.step2.outputs.test</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可用的runs-on：</p>
<table>
<thead>
<tr>
<th align="left">虚拟环境</th>
<th align="left">YAML 工作流程标签</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Windows Server 2019</td>
<td align="left"><code>windows-latest</code> 或 <code>windows-2019</code></td>
</tr>
<tr>
<td align="left">Ubuntu 18.04</td>
<td align="left"><code>ubuntu-latest</code> 或 <code>ubuntu-18.04</code></td>
</tr>
<tr>
<td align="left">Ubuntu 16.04</td>
<td align="left"><code>ubuntu-16.04</code></td>
</tr>
<tr>
<td align="left">macOS Catalina 10.15</td>
<td align="left"><code>macos-latest</code> 或 <code>macos-10.15</code></td>
</tr>
</tbody></table>
<h3 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h3><p><code>repo-&gt;settings-&gt;secrets</code>:</p>
<p>如{name: MYSECRET, value: my_val}</p>
<p>就可以用 <code>$</code>取出。</p>
<h3 id="上传build完成的文件"><a href="#上传build完成的文件" class="headerlink" title="上传build完成的文件"></a>上传build完成的文件</h3><h4 id="Upload-an-Individual-File"><a href="#Upload-an-Individual-File" class="headerlink" title="Upload an Individual File"></a>Upload an Individual File</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">steps:</span><br><span class="line">- uses: actions&#x2F;checkout@v2</span><br><span class="line"></span><br><span class="line">- run: mkdir -p path&#x2F;to&#x2F;artifact</span><br><span class="line"></span><br><span class="line">- run: echo hello &gt; path&#x2F;to&#x2F;artifact&#x2F;world.txt</span><br><span class="line"></span><br><span class="line">- uses: actions&#x2F;upload-artifact@v2</span><br><span class="line">  with:</span><br><span class="line">    name: my-artifact</span><br><span class="line">    path: path&#x2F;to&#x2F;artifact&#x2F;world.txt</span><br></pre></td></tr></table></figure>

<h4 id="Upload-an-Entire-Directory"><a href="#Upload-an-Entire-Directory" class="headerlink" title="Upload an Entire Directory"></a>Upload an Entire Directory</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- uses: actions&#x2F;upload-artifact@v2</span><br><span class="line">  with:</span><br><span class="line">    name: my-artifact</span><br><span class="line">    path: path&#x2F;to&#x2F;artifact&#x2F; # or path&#x2F;to&#x2F;artifact</span><br></pre></td></tr></table></figure>

<h4 id="Upload-using-a-Wildcard-Pattern"><a href="#Upload-using-a-Wildcard-Pattern" class="headerlink" title="Upload using a Wildcard Pattern:"></a>Upload using a Wildcard Pattern:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- uses: actions&#x2F;upload-artifact@v2</span><br><span class="line">  with:</span><br><span class="line">    name: my-artifact</span><br><span class="line">    path: path&#x2F;**&#x2F;[abc]rtifac?&#x2F;*</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NkcmFzL2F3ZXNvbWUtYWN0aW9ucw==">Awesome Actions<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vY24vYWN0aW9ucw==">官方帮助文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTkvMDkvZ2V0dGluZy1zdGFydGVkLXdpdGgtZ2l0aHViLWFjdGlvbnMuaHRtbA==">Github Actions入门<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>工具的使用</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/Blog/2020/06/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
</search>
